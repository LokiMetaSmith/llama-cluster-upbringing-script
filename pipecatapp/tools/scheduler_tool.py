import logging
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.date import DateTrigger
import asyncio

logger = logging.getLogger(__name__)

class SchedulerTool:
    """
    A tool for scheduling recurring tasks or reminders.
    Messages generated by this tool are injected into the agent's main loop as system alerts.
    """
    def __init__(self):
        self.scheduler = AsyncIOScheduler()
        # The scheduler needs a running event loop.
        # Since this tool is initialized in app.py which runs uvicorn, it should pick up the loop when started.
        self.scheduler.start()
        self.name = "scheduler"
        self.description = "Schedule recurring tasks or reminders using cron syntax or intervals."

    async def _inject_message(self, message: str):
        """Injects a message into the agent's input queue."""
        logger.info(f"Scheduler triggering message: {message}")
        try:
            import web_server
            if hasattr(web_server, 'text_message_queue'):
                await web_server.text_message_queue.put({
                    "text": f"SCHEDULED TASK: {message}",
                    "is_system_alert": True
                })
            else:
                logger.error("web_server.text_message_queue is not available.")
        except ImportError:
            logger.error("Could not import web_server to inject scheduled message.")

    async def add_cron_job(self, message: str, cron_expression: str) -> str:
        """
        Schedules a task using a standard cron expression.

        Args:
            message (str): The text to send to the agent.
            cron_expression (str): Standard 5-field cron string (min hour day month dow).
                                   e.g., "0 9 * * *" for daily at 9 AM.
                                   "*/15 * * * *" for every 15 minutes.
        """
        try:
            parts = cron_expression.strip().split()
            if len(parts) != 5:
                return "Error: Cron expression must have exactly 5 fields (minute hour day month day_of_week)."

            trigger = CronTrigger(
                minute=parts[0],
                hour=parts[1],
                day=parts[2],
                month=parts[3],
                day_of_week=parts[4]
            )
            job = self.scheduler.add_job(self._inject_message, trigger, args=[message])
            return f"Scheduled cron job '{message}' [ID: {job.id}] Next run: {job.next_run_time}"
        except Exception as e:
            logger.error(f"Scheduler error: {e}")
            return f"Failed to schedule job: {str(e)}"

    async def add_interval_job(self, message: str, minutes: int = 0, seconds: int = 0, hours: int = 0) -> str:
        """
        Schedules a task to run repeatedly at a fixed interval.
        """
        if minutes == 0 and seconds == 0 and hours == 0:
            return "Error: Interval must be greater than 0."

        try:
            trigger = IntervalTrigger(hours=hours, minutes=minutes, seconds=seconds)
            job = self.scheduler.add_job(self._inject_message, trigger, args=[message])
            return f"Scheduled interval job '{message}' [ID: {job.id}] Next run: {job.next_run_time}"
        except Exception as e:
            return f"Failed to schedule job: {str(e)}"

    def list_jobs(self) -> str:
        """Lists all currently scheduled jobs."""
        jobs = self.scheduler.get_jobs()
        if not jobs:
            return "No scheduled jobs."

        job_list = []
        for job in jobs:
            # job.args[0] is the message
            msg = job.args[0] if job.args else "Unknown"
            job_list.append(f"- ID: {job.id} | Next: {job.next_run_time} | Task: {msg}")
        return "\n".join(job_list)

    def remove_job(self, job_id: str) -> str:
        """Removes a scheduled job by ID."""
        try:
            self.scheduler.remove_job(job_id)
            return f"Job {job_id} removed."
        except Exception as e:
            return f"Error removing job: {str(e)}"
