import docker
import logging
import os
import tempfile
from llm_sandbox import SandboxSession
from typing import List, Optional
from .dependency_scanner_tool import DependencyScannerTool

class CodeRunnerTool:
    """A tool for executing Python code in a sandboxed Docker container.

    This class provides a method to run arbitrary Python code within a
    secure, isolated, and ephemeral Docker container. It's designed to
    safely execute code generated by the LLM.

    Attributes:
        description (str): A brief description of the tool's purpose.
        name (str): The name of the tool.
        client: The Docker client instance.
        image (str): The name of the Docker image to use for the container.
    """
    def __init__(self):
        """Initializes the CodeRunnerTool."""
        self.description = "Execute Python code in a sandboxed Docker container."
        self.name = "code_runner"
        try:
            self.client = docker.from_env()
        except Exception as e:
            logging.warning(f"Failed to initialize Docker client for CodeRunnerTool: {e}")
            self.client = None

        self.image = "python:3.9-slim"
        self.scanner = DependencyScannerTool()

    def run_python_code(self, code: str) -> str:
        """Runs a string of Python code in a Docker container and returns the output.

        The code is written to a temporary file, which is mounted read-only
        into a `python:3.9-slim` container. The container executes the script
        and its combined stdout and stderr are captured and returned.

        Args:
            code (str): The Python code to execute.

        Returns:
            str: The captured output (stdout and stderr) from the code
                 execution, or an error message if something went wrong.
        """
        if not self.client:
            return "Error: Docker execution is not available (Docker client failed to initialize)."

        try:
            # Use TemporaryDirectory for better isolation than mounting /tmp
            with tempfile.TemporaryDirectory() as temp_dir:
                script_name = "script.py"
                host_script_path = os.path.join(temp_dir, script_name)

                with open(host_script_path, "w") as f:
                    f.write(code)

                # Mount the temp dir to /code
                volumes = {temp_dir: {'bind': '/code', 'mode': 'ro'}}

                container = self.client.containers.run(
                    self.image,
                    command=["python", f"/code/{script_name}"],
                    volumes=volumes,
                    working_dir="/code",
                    network_mode="none",  # Security: No internet access
                    mem_limit="128m",     # Security: Limit memory
                    cpu_period=100000,
                    cpu_quota=50000,      # Security: Limit CPU (50%)
                    pids_limit=20,        # Security: Limit processes
                    remove=True,
                    stderr=True,
                    stdout=True
                )

                output = container.decode('utf-8')
                return output

        except docker.errors.ImageNotFound:
            return f"Error: The Docker image '{self.image}' was not found. Please pull it first."
        except Exception as e:
            return f"An error occurred: {e}"

    def run_code_in_sandbox(
        self,
        code: str,
        language: str = "python",
        libraries: Optional[List[str]] = None
    ) -> str:
        """Runs code in a secure llm-sandbox, with support for multiple languages.

        Args:
            code (str): The code to execute.
            language (str): The programming language. Defaults to "python".
                            Supported: python, javascript, java, cpp, go, r.
            libraries (Optional[List[str]]): A list of libraries to install.

        Returns:
            str: The execution output or an error message.
        """
        if libraries is None:
            libraries = []

        # Dependency Intelligence Check
        if language == "python" and libraries:
            for lib in libraries:
                # Basic parsing to separate package name from version if present
                # Simple split on '==' for now; robust parsing would use 'packaging' library
                if '==' in lib:
                    name, version = lib.split('==', 1)
                else:
                    name, version = lib, None

                scan_result = self.scanner.scan_package(name, version)
                if "UNSAFE" in scan_result:
                    return f"Operation blocked by security policy. Vulnerability detected in dependency '{lib}':\n{scan_result}"

        try:
            with SandboxSession(lang=language) as session:
                result = session.run(code, libraries=libraries)
                if result.exit_code == 0:
                    output = result.stdout
                else:
                    output = f"Exit Code: {result.exit_code}\n---STDERR---\n{result.stderr}\n---STDOUT---\n{result.stdout}"

                if result.plots:
                    output += "\n\nGenerated plots are available."

                return output
        except Exception as e:
            return f"An unexpected error occurred: {e}"
