<!DOCTYPE html>
<html>
<head>
    <title>Cluster VR Visualization</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- D3 Force 3D -->
    <script src="https://unpkg.com/d3"></script>
    <script src="https://unpkg.com/d3-force-3d"></script>
    <!-- HTML Embed -->
    <script src="https://supereggbert.github.io/aframe-htmlembed-component/dist/build.js"></script>
    <!-- LiteGraph -->
    <link rel="stylesheet" type="text/css" href="/static/css/litegraph.css">
    <script src="/static/js/litegraph.js"></script>
    <!-- Custom Editor Logic -->
    <script src="/static/js/editor.js"></script>

    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0f0; font-family: monospace; font-size: 24px; pointer-events: none;
            z-index: 999;
        }
        /* Hidden Container for LiteGraph Canvas */
        #main-canvas-container {
            width: 1024px;
            height: 1024px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
            pointer-events: none;
        }
        #mycanvas {
            background-color: #111;
        }
    </style>
</head>
<body>

    <div id="loading">Connecting to Cluster...</div>

    <!-- Hidden Container for LiteGraph Canvas -->
    <div id="main-canvas-container">
        <canvas id="mycanvas" width="1024" height="1024"></canvas>
    </div>

    <a-scene background="color: #050505" cursor="rayOrigin: mouse" raycaster="objects: .clickable">

        <a-assets>
            <img id="floor-texture" src="https://cdn.aframe.io/a-painter/images/floor.jpg">
            <audio id="ping-sound" src="https://cdn.aframe.io/360-image-gallery-boilerplate/audio/click.ogg"></audio>
        </a-assets>

        <!-- Player Rig -->
        <a-entity id="rig" position="0 2 10">
            <a-camera look-controls wasd-controls>
                <a-text id="hud-log" value="System: Initializing..." position="0 -0.5 -1" color="#00ff00" width="2" align="center"></a-text>
            </a-camera>
            <a-entity laser-controls="hand: right" raycaster="objects: .clickable; far: 50"></a-entity>
            <a-entity laser-controls="hand: left" raycaster="objects: .clickable; far: 50"></a-entity>
        </a-entity>

        <!-- Floor -->
        <a-plane rotation="-90 0 0" width="100" height="100" src="#floor-texture" repeat="20 20" color="#333"></a-plane>

        <!-- Container for Graph Nodes -->
        <a-entity id="graph-container" position="0 0 0"></a-entity>

        <!-- Log Panel -->
        <a-entity position="-4 3 0" rotation="0 45 0">
             <a-plane color="#000" opacity="0.7" width="3" height="4">
                 <a-text value="Live Logs" position="0 1.8 0.1" align="center" color="#fff"></a-text>
                 <a-text id="log-panel-text" value="Waiting for logs..." position="-1.4 1.5 0.1" width="2.8" align="left" baseline="top" wrap-count="35"></a-text>
             </a-plane>
        </a-entity>

        <!-- Stats Panel -->
        <a-entity position="4 3 0" rotation="0 -45 0">
             <a-plane color="#000" opacity="0.7" width="3" height="4">
                 <a-text value="Cluster Health" position="0 1.8 0.1" align="center" color="#fff"></a-text>
                 <a-text id="stats-panel-text" value="Loading metrics..." position="-1.4 1.5 0.1" width="2.8" align="left" baseline="top" wrap-count="30"></a-text>
             </a-plane>
        </a-entity>

        <!-- ComfyUI / Workflow Editor (To the Left) -->
        <a-entity position="-8 2.5 8" rotation="0 90 0">
            <a-text value="Workflow Editor" align="center" position="0 2.2 0" width="8"></a-text>
            <a-entity class="clickable" htmlembed="width:1024; height:1024;">
                <div id="vr-graph-container" style="width: 1024px; height: 1024px; background: #222;">
                    <!-- Canvas will be moved here by JS -->
                </div>
            </a-entity>
        </a-entity>

    </a-scene>

    <script>
        // --- 1. State & Config ---
        const SCENE_SCALE = 0.1; // Scale down d3 coordinates to VR space
        const GRAPH_CONTAINER = document.getElementById('graph-container');
        const LOG_TEXT = document.getElementById('log-panel-text');
        const STATS_TEXT = document.getElementById('stats-panel-text');
        const HUD_LOG = document.getElementById('hud-log');
        const LOADING = document.getElementById('loading');

        let nodes = [];
        let links = [];
        let nodeEntities = {}; // Map id -> a-entity
        // linkEntities is removed, we attach entity to link object
        let projectiles = [];
        let simulation = null;
        let audioManager = null;

        // Architecture Groups defining structure
        const GROUPS = {
            'core_infra': { color: '#F1E05A', label: 'Infra' },
            'app': { color: '#3572A5', label: 'App' },
            'service': { color: '#D19A66', label: 'Service' },
            'tools': { color: '#89E051', label: 'Tool' },
            'mgmt': { color: '#EE0000', label: 'Mgmt' }
        };

        function showError(msg) {
            console.error(msg);
            LOADING.style.display = 'none';
            HUD_LOG.setAttribute('value', "Error: " + msg);
            // Create visible error text
            const errEntity = document.createElement('a-text');
            errEntity.setAttribute('value', msg);
            errEntity.setAttribute('color', 'red');
            errEntity.setAttribute('position', '0 2 0');
            errEntity.setAttribute('align', 'center');
            errEntity.setAttribute('scale', '2 2 2');
            document.querySelector('a-scene').appendChild(errEntity);
        }

        // --- Audio Manager ---
        class AudioManager {
            constructor() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.nodes = {}; // map id -> { osc, gain, panner }
                this.enabled = false;

                // Unlock audio on first interaction
                window.addEventListener('click', () => {
                    if (this.ctx.state === 'suspended') {
                        this.ctx.resume();
                    }
                    this.enabled = true;
                }, { once: true });
            }

            createNodeSound(id) {
                if (!this.ctx) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createPanner();

                panner.panningModel = 'HRTF';
                panner.distanceModel = 'inverse';
                panner.refDistance = 2;
                panner.maxDistance = 50;
                panner.rolloffFactor = 1;

                osc.type = 'sine';
                osc.frequency.value = 100; // Base freq
                gain.gain.value = 0;       // Start silent

                osc.connect(gain);
                gain.connect(panner);
                panner.connect(this.ctx.destination);

                osc.start();

                this.nodes[id] = { osc, gain, panner };
            }

            updateNodeSound(id, cpu, pos) {
                if (!this.nodes[id]) this.createNodeSound(id);
                const n = this.nodes[id];

                // Update Position
                if (n.panner.positionX) {
                    n.panner.positionX.value = pos.x;
                    n.panner.positionY.value = pos.y;
                    n.panner.positionZ.value = pos.z;
                } else {
                    n.panner.setPosition(pos.x, pos.y, pos.z);
                }

                // Update Pitch & Volume based on CPU
                // CPU is 0.0 to 1.0 (or > 1.0)
                // Pitch: 100Hz + (cpu * 200) -> 100Hz to 300Hz typical
                // Volume: 0.0 + (cpu * 0.2) -> Max 0.2 to not be deafening

                const safeCpu = Math.max(0, cpu || 0);
                const targetFreq = 100 + (safeCpu * 400);
                const targetGain = this.enabled ? Math.min(0.2, safeCpu * 0.1) : 0;

                // Smooth transitions
                const now = this.ctx.currentTime;
                n.osc.frequency.setTargetAtTime(targetFreq, now, 0.1);
                n.gain.gain.setTargetAtTime(targetGain, now, 0.1);
            }

            removeNodeSound(id) {
                if (this.nodes[id]) {
                    const n = this.nodes[id];
                    n.gain.disconnect();
                    n.panner.disconnect();
                    n.osc.stop();
                    delete this.nodes[id];
                }
            }
        }

        audioManager = new AudioManager();

        // --- Editor Init ---
        // Move canvas to VR container and init LiteGraph
        try {
            const canvas = document.getElementById("mycanvas");
            document.getElementById('vr-graph-container').appendChild(canvas);

            if (typeof WorkflowEditor !== 'undefined') {
                WorkflowEditor.init("mycanvas", { skipResize: true });

                // Throttling for VR performance
                let lastDraw = 0;
                const FPS_LIMIT = 30;
                const INTERVAL = 1000 / FPS_LIMIT;
                WorkflowEditor.graph.onAfterExecute = function() {
                    const now = Date.now();
                    if (now - lastDraw > INTERVAL) {
                        WorkflowEditor.canvas.draw(true);
                        lastDraw = now;
                    }
                };
                WorkflowEditor.graph.start();
            } else {
                console.warn("WorkflowEditor not found");
            }
        } catch(e) {
            console.error("Editor Init Error", e);
        }

        try {
            if (typeof d3 === 'undefined') {
                throw new Error("D3 library failed to load.");
            }

            // D3 Init
            simulation = d3.forceSimulation()
                .numDimensions(3)
                .force('link', d3.forceLink().id(d => d.id).distance(40)) // Default distance
                .force('charge', d3.forceManyBody().strength(-100))      // Repulsion
                .force('center', d3.forceCenter(0, 50, 0))               // Center slightly up
                .force('y', d3.forceY(20).strength(0.1));                // Keep somewhat grounded

            simulation.on('tick', () => {
                // Update A-Frame Entities positions
                nodes.forEach(node => {
                    const el = nodeEntities[node.id];
                    if (el) {
                        const x = node.x * SCENE_SCALE;
                        const y = Math.max(0.5, node.y * SCENE_SCALE);
                        const z = node.z * SCENE_SCALE;

                        el.object3D.position.set(x, y, z);

                        // Update Audio Position
                        if (audioManager) {
                            audioManager.updateNodeSound(node.id, node.cpu, {x, y, z});
                        }
                    }
                });

                links.forEach(link => {
                    const line = link._entity;
                    if (line) {
                        const start = { x: link.source.x * SCENE_SCALE, y: link.source.y * SCENE_SCALE, z: link.source.z * SCENE_SCALE };
                        const end = { x: link.target.x * SCENE_SCALE, y: link.target.y * SCENE_SCALE, z: link.target.z * SCENE_SCALE };

                        line.setAttribute('line', {
                            start: start,
                            end: end,
                            color: '#555'
                        });
                    }
                });
            });

            // Start Polling
            setInterval(updateGraph, 2000);
            updateGraph(); // Initial

        } catch (e) {
            showError(e.message);
        }

        // --- 3. Data Fetching & Graph Building ---
        async function updateGraph() {
            if (!simulation) return;
            try {
                const res = await fetch('/api/cluster/metrics');
                if (!res.ok) throw new Error("API Error " + res.status);
                const metrics = await res.json();

                // Construct Nodes from Metrics
                let newNodes = [];
                let newLinks = [];

                // Add a central hub "Conductor" if not present
                // We'll use 'pipecat_app' as the main hub or create a virtual one
                // Check if 'pipecat_app' exists in metrics, if not add it manually for structure
                let appNodeExists = metrics.find(m => m.id.includes('pipecat') || m.id === 'pipecat_app');

                // Helper to classify
                const classify = (id) => {
                    if (id.includes('nomad') || id.includes('consul')) return 'core_infra';
                    if (id.includes('pipecat')) return 'app';
                    if (id.includes('tool')) return 'tools';
                    return 'service';
                };

                // 1. Mark all as potentially missing
                nodes.forEach(n => n._seen = false);

                metrics.forEach(m => {
                    // Update or Add Node
                    let existing = nodes.find(n => n.id === m.id);
                    if (!existing) {
                        existing = {
                            id: m.id,
                            group: classify(m.id),
                            cpu: m.cpu,
                            mem: m.mem,
                            status: m.status || 'healthy',
                            x: (Math.random()-0.5)*100,
                            y: (Math.random())*50,
                            z: (Math.random()-0.5)*100,
                            _seen: true
                        };
                        nodes.push(existing);
                        createNodeEntity(existing);
                    } else {
                        existing.cpu = m.cpu;
                        existing.mem = m.mem;
                        existing.status = m.status || 'healthy';
                        existing._seen = true;
                        updateNodeVisuals(existing);
                    }
                });

                // 2. Handle Broken/Missing Nodes
                // If a node is missing from metrics OR status is unhealthy/unreachable
                // We sever its links.

                const brokenNodes = nodes.filter(n => !n._seen || n.status !== 'healthy' && n.status !== 'running');

                if (brokenNodes.length > 0) {
                    // Remove links connected to broken nodes
                    for (let i = links.length - 1; i >= 0; i--) {
                        const l = links[i];
                        // D3 replaces source/target with objects
                        const sId = l.source.id || l.source;
                        const tId = l.target.id || l.target;

                        if (brokenNodes.find(n => n.id === sId || n.id === tId)) {
                            // Destroy link entity
                            if (l._entity) {
                                l._entity.parentNode.removeChild(l._entity);
                                l._entity = null;
                            }
                            links.splice(i, 1);
                        }
                    }

                    // Visual update for broken nodes
                    brokenNodes.forEach(n => {
                        updateNodeVisuals(n); // Ensure it turns red
                        // Also silence it
                        if (audioManager) audioManager.removeNodeSound(n.id);
                    });
                }

                // Update Links (Naive Topology: All -> App/Infra)
                // Only connect HEALTHY nodes
                const healthyNodes = nodes.filter(n => !brokenNodes.includes(n));
                const appNodes = healthyNodes.filter(n => n.group === 'app');
                const infraNodes = healthyNodes.filter(n => n.group === 'core_infra');

                healthyNodes.forEach(n => {
                    // Skip if already has links (optimization? D3 handles dupes via checks)
                    // But we removed links for broken nodes, so we need to ensure connectivity for others.
                    // To avoid dupes, addLink checks existence.

                    if (n.group !== 'app' && n.group !== 'core_infra') {
                        if (appNodes.length > 0) addLink(n, appNodes[0]);
                        else if (infraNodes.length > 0) addLink(n, infraNodes[0]);
                    }
                    if (n.group === 'app') {
                        if (infraNodes.length > 0) addLink(n, infraNodes[0]);
                    }
                });

                // Restart simulation with new data
                simulation.nodes(nodes);
                simulation.force('link').links(links);
                simulation.alpha(0.3).restart();

                updateStatsPanel(metrics);
                LOADING.style.display = 'none';
                HUD_LOG.setAttribute('value', "System: Online");

            } catch (e) {
                console.error("Graph Update Error", e);
                LOADING.style.display = 'none';
                HUD_LOG.setAttribute('value', "System: Connection Lost");
            }
        }

        function addLink(source, target) {
            // Check if link exists
            const exists = links.find(l => (l.source.id === source.id && l.target.id === target.id) || (l.source.id === target.id && l.target.id === source.id));
            if (!exists) {
                const link = { source: source.id, target: target.id }; // d3 will resolve to objects
                createLinkEntity(link);
                links.push(link);
            }
        }

        function createNodeEntity(node) {
            const el = document.createElement('a-box');
            el.setAttribute('id', `node-${node.id}`);
            el.setAttribute('class', 'clickable');
            el.setAttribute('color', GROUPS[node.group].color);
            el.setAttribute('width', 1);
            el.setAttribute('depth', 1);
            // Height based on Mem? Start default
            el.setAttribute('height', 1);
            el.setAttribute('shadow', '');

            // Label
            const text = document.createElement('a-text');
            text.setAttribute('value', node.id);
            text.setAttribute('align', 'center');
            text.setAttribute('position', '0 1.2 0');
            text.setAttribute('side', 'double');
            text.setAttribute('scale', '2 2 2');
            el.appendChild(text);

            GRAPH_CONTAINER.appendChild(el);
            nodeEntities[node.id] = el;

            // Interaction
            el.addEventListener('click', () => {
                HUD_LOG.setAttribute('value', `Selected: ${node.id}`);
            });
            // Make Draggable? (Simplified: Just log for now, full drag logic is complex in vanilla A-Frame without extra components)
        }

        function updateNodeVisuals(node) {
            const el = nodeEntities[node.id];
            if (!el) return;

            // Check for broken status
            const isBroken = (!node._seen || (node.status && node.status !== 'healthy' && node.status !== 'running'));

            if (isBroken) {
                el.setAttribute('color', '#555555'); // Dead/Grey
                // Or flashing red?
                // Simple grey for "disconnected"
                el.setAttribute('opacity', 0.5);
                return;
            } else {
                el.setAttribute('opacity', 1.0);
            }

            // Height = Mem (base 1 + mem / 100MB)
            const memMB = (node.mem / (1024*1024));
            const height = 1 + (memMB / 500);
            el.setAttribute('height', Math.min(height, 10)); // Cap at 10

            // Color/Pulse = CPU
            const cpu = node.cpu || 0;
            if (cpu > 0.8) {
                el.setAttribute('color', '#ff0000'); // Hot!
            } else if (cpu > 0.5) {
                el.setAttribute('color', '#ff8800'); // Warm
            } else {
                el.setAttribute('color', GROUPS[node.group].color);
            }
        }

        function createLinkEntity(link) {
            const el = document.createElement('a-entity');
            el.setAttribute('line', 'color: #555; opacity: 0.5');
            GRAPH_CONTAINER.appendChild(el);
            link._entity = el;
        }

        // --- 4. Projectiles (Traffic Simulation) ---
        function spawnProjectile(sourceId, targetId) {
            const sourceEl = nodeEntities[sourceId];
            const targetEl = nodeEntities[targetId];
            if (!sourceEl || !targetEl) return;

            const sphere = document.createElement('a-sphere');
            sphere.setAttribute('radius', 0.2);
            sphere.setAttribute('color', '#00ffff');
            sphere.setAttribute('shader', 'flat');
            GRAPH_CONTAINER.appendChild(sphere);

            // Animation data
            const start = sourceEl.object3D.position.clone();
            const end = targetEl.object3D.position.clone();

            // Simple animation loop
            let progress = 0;
            const speed = 0.05;

            const animateProjectile = () => {
                progress += speed;
                if (progress >= 1) {
                    sphere.parentNode.removeChild(sphere);
                    return;
                }
                const pos = new THREE.Vector3().lerpVectors(start, end, progress);
                sphere.object3D.position.copy(pos);
                requestAnimationFrame(animateProjectile);
            };
            animateProjectile();
        }

        function randomTraffic() {
            // Pick random link and spawn projectile
            if (links.length > 0) {
                const link = links[Math.floor(Math.random() * links.length)];
                // D3 resolves source/target to objects, so use .id
                spawnProjectile(link.source.id, link.target.id);
            }
        }
        setInterval(randomTraffic, 500); // Constant background chatter

        // --- 5. WebSocket & Stats ---
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
        let logs = [];

        ws.onopen = () => {
            console.log("WS Connected");
            HUD_LOG.setAttribute('value', "System: Connected");
        };

        ws.onmessage = (e) => {
            const msg = JSON.parse(e.data);
            if (msg.type === 'log' || msg.type === 'agent' || msg.type === 'user') {
                const text = `[${msg.type.toUpperCase()}] ${msg.data || msg.message}`;
                logs.push(text);
                if (logs.length > 15) logs.shift();
                LOG_TEXT.setAttribute('value', logs.join('\n'));

                // Trigger a projectile from App to somewhere if log indicates activity?
                // Just random burst for now
                randomTraffic();
            }
        };

        function updateStatsPanel(metrics) {
            let text = "Active Nodes: " + metrics.length + "\n\n";
            metrics.forEach(m => {
                text += `${m.id.substring(0, 12)}... \nCPU: ${(m.cpu*100).toFixed(0)}% MEM: ${(m.mem/1024/1024).toFixed(0)}MB\n\n`;
            });
            STATS_TEXT.setAttribute('value', text);
        }

        // --- 6. Init ---
        // (Moved to top-level to handle loading async if needed, but D3 init is sync)

    </script>
</body>
</html>