- block:
    - name: "Expert {{ expert_name }} : Check if {{ pipecat_image_name }}:{{ pipecat_image_tag }} image exists"
      ansible.builtin.command: "docker image inspect {{ pipecat_image_name }}:{{ pipecat_image_tag }}"
      register: pipecat_image_check
      failed_when: false
      changed_when: false

    - name: "Expert {{ expert_name }} : Ensure pipecatapp directory exists"
      ansible.builtin.file:
        path: "{{ pipecat_app_mount_source }}"
        state: directory
        mode: '0755'

    - name: "Expert {{ expert_name }} : Synchronize pipecatapp source"
      ansible.posix.synchronize:
        src: "{{ inventory_dir }}/pipecatapp/"
        dest: "{{ pipecat_app_mount_source }}/"
        rsync_opts:
          - "--exclude=.git"
          - "--exclude=venv"
          - "--exclude=__pycache__"
          - "--exclude=*.pyc"
          - "--exclude=start_pipecat.sh"
        rsync_path: "sudo rsync"

    - name: "Expert {{ expert_name }} : Build pipecatapp image if missing"
      block:
        - name: "Expert {{ expert_name }} : Build {{ pipecat_image_name }} Docker image"
          ansible.builtin.include_tasks:
            file: "{{ inventory_dir }}/ansible/tasks/build_pipecatapp_image.yaml"
          vars:
            pipecat_build_dir: "{{ pipecat_app_mount_source }}"

        - name: "Expert {{ expert_name }} : Tag {{ pipecat_image_name }}:{{ pipecat_image_tag }}"
          ansible.builtin.command: "docker tag {{ pipecat_image_name }}:{{ pipecat_image_tag }} {{ pipecat_image_name }}:{{ pipecat_image_tag }}"
      when: pipecat_image_check.rc != 0

    - name: "Expert {{ expert_name }} : Refresh {{ pipecat_image_name }}:{{ pipecat_image_tag }} tag for Nomad"
      ansible.builtin.command: "docker tag {{ pipecat_image_name }}:{{ pipecat_image_tag }} {{ pipecat_image_name }}:{{ pipecat_image_tag }}"
      changed_when: false

    - name: "Expert {{ expert_name }} : Check if local registry is reachable"
      ansible.builtin.wait_for:
        host: "{{ docker_registry_host }}"
        port: "{{ docker_registry_port }}"
        state: started
        timeout: 5
      register: registry_check
      ignore_errors: true
      when: registry_is_reachable | default(true)

    - name: "Expert {{ expert_name }} : Tag and push {{ pipecat_image_name }} image to local registry"
      community.docker.docker_image:
        name: "{{ pipecat_image_name }}"
        tag: "{{ pipecat_image_tag }}"
        repository: "{{ docker_registry_host }}:{{ docker_registry_port }}/{{ pipecat_image_name }}"
        push: true
        source: local
      when:
        - registry_is_reachable | default(true)
        - registry_check is success

    - name: "Expert {{ expert_name }} : Ensure startup script exists (Dev Mode fallback)"
      ansible.builtin.template:
        src: "{{ inventory_dir }}/ansible/roles/pipecatapp/templates/start_pipecatapp.sh.j2"
        dest: "{{ pipecat_app_mount_source }}/start_pipecat.sh"
        mode: '0755'

    - name: "Expert {{ expert_name }} : Check if job exists"
      ansible.builtin.command:
        cmd: "/usr/local/bin/nomad job status expert-{{ expert_name }}"
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_job_status_check
      failed_when: false
      changed_when: false

    - name: "Expert {{ expert_name }} : Purge existing nomad job"
      ansible.builtin.command:
        cmd: "/usr/local/bin/nomad job stop -purge expert-{{ expert_name }}"
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_purge_result
      failed_when: false
      when: expert_job_status_check.rc == 0
      changed_when: true

    - name: "Expert {{ expert_name }} : Run nomad job"
      ansible.builtin.command: >
        /usr/local/bin/nomad job run
        -var="job_name=expert-{{ expert_name }}"
        -var="service_name=expert-api-{{ expert_name }}"
        -var="rpc_pool_job_name=llamacpp-rpc-pool"
        /tmp/expert-{{ expert_name }}.nomad
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      changed_when: true
      register: expert_job_run

  rescue:
    - name: "Expert {{ expert_name }} : Debug Job Run Failure"
      ansible.builtin.debug:
        var: expert_job_run
      when: expert_job_run is defined

    - name: "Expert {{ expert_name }} : Run nomad job plan for debugging"
      ansible.builtin.command: >
        /usr/local/bin/nomad job plan
        -var="job_name=expert-{{ expert_name }}"
        -var="service_name=expert-api-{{ expert_name }}"
        -var="rpc_pool_job_name=llamacpp-rpc-pool"
        /tmp/expert-{{ expert_name }}.nomad
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_job_plan_debug
      failed_when: false
      changed_when: false

    - name: "Expert {{ expert_name }} : Display job plan result"
      ansible.builtin.debug:
        var: expert_job_plan_debug

    - name: "Expert {{ expert_name }} : Debug Nomad File Content"
      ansible.builtin.command: "cat /tmp/expert-{{ expert_name }}.nomad"
      register: expert_nomad_file_content
      changed_when: false

    - name: "Expert {{ expert_name }} : Show Nomad File"
      ansible.builtin.debug:
        var: expert_nomad_file_content.stdout

    - name: "Expert {{ expert_name }} : Get job status"
      ansible.builtin.command:
        cmd: /usr/local/bin/nomad job status -verbose expert-{{ expert_name }}
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_job_status
      failed_when: false

    - name: "Expert {{ expert_name }} : Display job status"
      ansible.builtin.debug:
        var: expert_job_status.stdout

    - name: "Expert {{ expert_name }} : Get allocations"
      ansible.builtin.command:
        cmd: /usr/local/bin/nomad job allocs -json expert-{{ expert_name }}
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_allocs
      failed_when: false

    - name: "Expert {{ expert_name }} : Save allocations to temp file"
      ansible.builtin.copy:
        content: "{{ expert_allocs.stdout }}"
        dest: "/tmp/expert_{{ expert_name }}_allocs.json"

    - name: "Expert {{ expert_name }} : Analyze allocations"
      ansible.builtin.command:
        cmd: "python3 {{ playbook_dir }}/../../scripts/analyze_nomad_allocs.py /tmp/expert_{{ expert_name }}_allocs.json"
      register: expert_allocs_analysis
      changed_when: false
      failed_when: false

    - name: "Expert {{ expert_name }} : Extract Allocation ID"
      ansible.builtin.shell: "jq -r 'sort_by(.CreateTime) | reverse | .[0].ID' /tmp/expert_{{ expert_name }}_allocs.json"
      register: expert_alloc_id
      failed_when: false

    - name: "Expert {{ expert_name }} : Fetch logs (stdout)"
      ansible.builtin.command:
        cmd: "/usr/local/bin/nomad alloc logs {{ expert_alloc_id.stdout }}"
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_logs_stdout
      failed_when: false
      when: expert_alloc_id.stdout | length > 0

    - name: "Expert {{ expert_name }} : Display logs (stdout)"
      ansible.builtin.debug:
        var: expert_logs_stdout.stdout
      when: expert_logs_stdout.stdout is defined

    - name: "Expert {{ expert_name }} : Fetch logs (stderr)"
      ansible.builtin.command:
        cmd: "/usr/local/bin/nomad alloc logs -stderr {{ expert_alloc_id.stdout }}"
      environment:
        NOMAD_ADDR: "http://{{ cluster_ip }}:{{ nomad_http_port }}"
      register: expert_logs_stderr
      failed_when: false
      when: expert_alloc_id.stdout | length > 0

    - name: "Expert {{ expert_name }} : Display logs (stderr)"
      ansible.builtin.debug:
        var: expert_logs_stderr.stdout
      when: expert_logs_stderr.stdout is defined

    # --- Debugging via local file (fix for missing logs) ---
    - name: "Expert {{ expert_name }} : Read local startup.log"
      ansible.builtin.command: "cat {{ pipecat_app_mount_source }}/startup.log"
      register: expert_local_log
      failed_when: false
      changed_when: false

    - name: "Expert {{ expert_name }} : Display local startup.log"
      ansible.builtin.debug:
        var: expert_local_log.stdout
      when: expert_local_log.stdout is defined

    - name: "Expert {{ expert_name }} : Fail after debugging"
      ansible.builtin.fail:
        msg: |
          Expert {{ expert_name }} job failed to start.

          --- LOCAL STARTUP LOG (from {{ pipecat_app_mount_source }}/startup.log) ---
          {{ (expert_local_log | default({})).stdout | default('No local log found') }}

          --- FAILURE ANALYSIS ---
          {{ (expert_allocs_analysis | default({})).stdout | default('No analysis available') }}

          --- PURGE OUTPUT ---
          {{ (expert_purge_result | default({})).stderr | default((expert_purge_result | default({})).stdout) | default('N/A') }}

          --- RUN ERROR (stderr) ---
          {{ (expert_job_run | default({})).stderr | default('N/A') }}

          --- RUN OUTPUT (stdout) ---
          {{ (expert_job_run | default({})).stdout | default('N/A') }}

          --- JOB STATUS ---
          {{ (expert_job_status | default({})).stdout | default('N/A') }}

          --- ALLOCATIONS (JSON) ---
          (See /tmp/expert_{{ expert_name }}_allocs.json for full dump)
          {{ (expert_allocs | default({})).stdout | default('N/A') }}

          --- PLAN OUTPUT ---
          {{ (expert_job_plan_debug | default({})).stdout | default('N/A') }}

          --- PLAN ERROR ---
          {{ (expert_job_plan_debug | default({})).stderr | default('N/A') }}
