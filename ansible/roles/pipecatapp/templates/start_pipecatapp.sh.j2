#!/bin/bash
#
# Unified Wrapper Script for pipecatapp
#
# This script is generated by Ansible and ensures that the pipecat application
# is run correctly in both raw_exec and Docker environments.

# Exit immediately if a command exits with a non-zero status.
set -e

# Detect execution environment and set APP_DIR
# If running inside a Docker container (indicated by /.dockerenv), use the container path.
# Otherwise, use the Ansible variable (host path).
if [ -f /.dockerenv ]; then
    APP_DIR="/opt/pipecatapp"
else
    APP_DIR="{{ pipecat_app_dir }}"
fi

# Define log file path in the app directory (bind-mounted in dev mode)
LOG_FILE="$APP_DIR/startup.log"

# Function to log message to both stderr and file
log_msg() {
    echo "$@" | tee -a "$LOG_FILE" >&2
}

# Redirect all subsequent output to the log file while preserving stderr
# We use process substitution to tee everything to the log file.
# Note: set -e might cause issues with process substitution if tee fails, but usually safe.
# We'll use a simpler approach: explicitly logging key steps and redirecting the final python exec.

# Ensure the log file is created/writable
touch "$LOG_FILE" || echo "Warning: Could not create log file at $LOG_FILE" >&2

log_msg "--- Starting pipecat-app wrapper: $(date) ---"

# Install system dependencies if running as root in a Debian-based system (e.g. Docker dev mode)
if [ -f "/etc/debian_version" ] && [ "$(id -u)" -eq 0 ]; then
    if ! command -v git &> /dev/null || ! command -v pkg-config &> /dev/null; then
        log_msg "Installing system dependencies..."
        apt-get update && apt-get install -y --no-install-recommends \
            build-essential \
            python3-dev \
            portaudio19-dev \
            mecab \
            libmecab-dev \
            mecab-ipadic-utf8 \
            rustc \
            cargo \
            libevent-2.1-7 \
            libgstreamer-plugins-bad1.0-0 \
            libflite1 \
            libgl1-mesa-glx \
            libglib2.0-0 \
            libavif15 \
            gstreamer1.0-libav \
            libavcodec-dev \
            libavdevice-dev \
            libavfilter-dev \
            libavformat-dev \
            libavutil-dev \
            libswresample-dev \
            libswscale-dev \
            pkg-config \
            git 2>&1 | tee -a "$LOG_FILE"
    else
        log_msg "System dependencies appear to be installed."
    fi
fi

# Change to the application directory
cd "$APP_DIR"

# Source environment variables if present
if [ -f "$APP_DIR/pipecat.env" ]; then
    log_msg "Sourcing pipecat.env"
    source "$APP_DIR/pipecat.env"
fi

try_create_venv() {
    local venv_path=$1
    log_msg "Attempting to create venv at $venv_path..."

    if [ -d "$venv_path" ]; then
        log_msg "Removing existing venv at $venv_path..."
        if ! rm -rf "$venv_path"; then
             log_msg "Warning: Failed to remove $venv_path. Permission denied?"
        fi
    fi

    set +e
    python3 -m venv "$venv_path" 2>&1 | tee -a "$LOG_FILE"
    local ret=$?
    set -e

    if [ $ret -ne 0 ]; then
        log_msg "Failed to create venv at $venv_path"
        return 1
    fi
    return 0
}

# Try standard location first, then fallback
VENV_DIR="$APP_DIR/venv"
FALLBACK_VENV_DIR="/opt/venv"
EMERGENCY_VENV_DIR="/tmp/venv"

ACTIVATE=""

# Check if existing venv is compatible with current python version
if [ -d "$VENV_DIR" ] && [ -f "$VENV_DIR/bin/python3" ]; then
    CURRENT_VER=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
    VENV_VER=$("$VENV_DIR/bin/python3" -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "invalid")

    if [ "$CURRENT_VER" != "$VENV_VER" ]; then
        log_msg "Virtual environment version mismatch (System: $CURRENT_VER, Venv: $VENV_VER). Recreating..."
        rm -rf "$VENV_DIR"
    fi
fi

if [ -f "$VENV_DIR/bin/activate" ]; then
    log_msg "Found existing venv at $VENV_DIR"
    ACTIVATE="$VENV_DIR/bin/activate"
    source "$ACTIVATE"
else
    log_msg "Virtual environment not found. Attempting to create..."

    if try_create_venv "$VENV_DIR"; then
        ACTIVATE="$VENV_DIR/bin/activate"
    elif try_create_venv "$FALLBACK_VENV_DIR"; then
        ACTIVATE="$FALLBACK_VENV_DIR/bin/activate"
    elif try_create_venv "$EMERGENCY_VENV_DIR"; then
        ACTIVATE="$EMERGENCY_VENV_DIR/bin/activate"
    else
        log_msg "Critical: Failed to create virtual environment in all locations."
        exit 1
    fi

    source "$ACTIVATE"
fi

log_msg "Installing dependencies..."
pip install --upgrade pip 2>&1 | tee -a "$LOG_FILE"
pip install -r requirements.txt 2>&1 | tee -a "$LOG_FILE"

log_msg "Installing Playwright browsers..."
playwright install 2>&1 | tee -a "$LOG_FILE"

log_msg "--- Launching pipecat-app: $(date) ---"

# Add parent directory of app to PYTHONPATH so that 'import pipecatapp' works from within submodules
export PYTHONPATH=$PYTHONPATH:$(dirname "$APP_DIR")

{% if pipecat_deployment_style == 'raw_exec' %}
# For raw_exec, we explicitly manage our own log file via redirection.
exec "$APP_DIR/venv/bin/python3" -u "$APP_DIR/app.py" >> "$LOG_FILE" 2>&1
{% else %}
# For Docker, we want logs to stdout/stderr (for `docker logs`) AND to the file (for debugging).
# We use process substitution to pipe to tee.
# Note: We rely on the active venv here.
exec python3 -u "$APP_DIR/app.py" 2>&1 | tee -a "$LOG_FILE"
{% endif %}
