#!/bin/bash
#
# Unified Wrapper Script for pipecatapp
#
# This script is generated by Ansible and ensures that the pipecat application
# is run correctly in both raw_exec and Docker environments.

# Exit immediately if a command exits with a non-zero status.
set -e

# Install system dependencies if running as root in a Debian-based system (e.g. Docker dev mode)
if [ -f "/etc/debian_version" ] && [ "$(id -u)" -eq 0 ]; then
    if ! command -v git &> /dev/null || ! command -v pkg-config &> /dev/null; then
        echo "Installing system dependencies..."
        apt-get update && apt-get install -y --no-install-recommends \
            build-essential \
            python3-dev \
            portaudio19-dev \
            mecab \
            libmecab-dev \
            mecab-ipadic-utf8 \
            rustc \
            cargo \
            libevent-2.1-7 \
            libgstreamer-plugins-bad1.0-0 \
            libflite1 \
            libgl1-mesa-glx \
            libglib2.0-0 \
            libavif15 \
            gstreamer1.0-libav \
            libavcodec-dev \
            libavdevice-dev \
            libavfilter-dev \
            libavformat-dev \
            libavutil-dev \
            libswresample-dev \
            libswscale-dev \
            pkg-config \
            git
    else
        echo "System dependencies appear to be installed."
    fi
fi

# Change to the application directory
cd "{{ pipecat_app_dir }}"

# Source environment variables if present
if [ -f "{{ pipecat_app_dir }}/pipecat.env" ]; then
    source "{{ pipecat_app_dir }}/pipecat.env"
fi

setup_venv() {
    local venv_path=$1
    echo "Creating virtual environment at $venv_path..."

    set +e
    python3 -m venv "$venv_path"
    local ret=$?
    set -e

    if [ $ret -ne 0 ]; then
        echo "Failed to create venv at $venv_path"
        return 1
    fi

    source "$venv_path/bin/activate"

    echo "Installing dependencies..."
    pip install --upgrade pip
    pip install -r requirements.txt

    echo "Installing Playwright browsers..."
    playwright install
}

# Try standard location first, then fallback
VENV_DIR="{{ pipecat_app_dir }}/venv"
FALLBACK_VENV_DIR="/opt/venv"

if [ -f "$VENV_DIR/bin/activate" ]; then
    source "$VENV_DIR/bin/activate"
else
    echo "Virtual environment not found or broken at $VENV_DIR. Attempting to create..."
    rm -rf "$VENV_DIR"

    if ! setup_venv "$VENV_DIR"; then
        echo "Retrying with fallback location: $FALLBACK_VENV_DIR"
        rm -rf "$FALLBACK_VENV_DIR"
        if ! setup_venv "$FALLBACK_VENV_DIR"; then
             echo "Critical: Failed to create virtual environment in both $VENV_DIR and $FALLBACK_VENV_DIR"
             exit 1
        fi
    fi
fi

echo "--- Starting pipecat-app: $(date) ---"

# Add parent directory of app to PYTHONPATH so that 'import pipecatapp' works from within submodules
export PYTHONPATH=$PYTHONPATH:$(dirname "{{ pipecat_app_dir }}")

{% if pipecat_deployment_style == 'raw_exec' %}
# For raw_exec, we manage our own log file.
LOG_FILE="{{ pipecat_log_file }}"
touch "$LOG_FILE"
exec "{{ pipecat_app_dir }}/venv/bin/python3" "{{ pipecat_app_dir }}/app.py" >> "$LOG_FILE" 2>&1
{% else %}
# For Docker, we log to stdout/stderr and let the container runtime handle it.
# Note: We rely on the active venv here.
exec python3 "{{ pipecat_app_dir }}/app.py"
{% endif %}
