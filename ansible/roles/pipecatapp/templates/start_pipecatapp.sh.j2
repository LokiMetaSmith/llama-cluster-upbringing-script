#!/bin/bash
#
# Unified Wrapper Script for pipecatapp
#
# This script is generated by Ansible and ensures that the pipecat application
# is run correctly in both raw_exec and Docker environments.

# Exit immediately if a command exits with a non-zero status.
set -e
set -o pipefail

# Detect execution environment and set APP_DIR
# If running inside a Docker container (indicated by /.dockerenv), use the container path.
# Otherwise, use the Ansible variable (host path).
if [ -f /.dockerenv ]; then
    APP_DIR="/opt/pipecatapp"
    IS_DOCKER=1
else
    APP_DIR="{{ pipecat_app_dir }}"
    IS_DOCKER=0
fi

# Define log file path in the app directory (bind-mounted in dev mode)
LOG_FILE="$APP_DIR/startup.log"

# Function to log message to both stderr and file
log_msg() {
    echo "$@" | tee -a "$LOG_FILE" >&2
}

# Redirect all subsequent output to the log file while preserving stderr
# We use process substitution to tee everything to the log file.
# Note: set -e might cause issues with process substitution if tee fails, but usually safe.
# We'll use a simpler approach: explicitly logging key steps and redirecting the final python exec.

# Ensure the log file is created/writable
touch "$LOG_FILE" || echo "Warning: Could not create log file at $LOG_FILE (User: $(id))" >&2

log_msg "--- Starting pipecat-app wrapper: $(date) ---"

# Install system dependencies if running as root in a Debian-based system (e.g. Docker dev mode)
if [ -f "/etc/debian_version" ] && [ "$(id -u)" -eq 0 ]; then
    if ! command -v git &> /dev/null || ! command -v pkg-config &> /dev/null; then
        log_msg "Installing system dependencies..."
        apt-get update && apt-get install -y --no-install-recommends \
            build-essential \
            python3-dev \
            portaudio19-dev \
            mecab \
            libmecab-dev \
            mecab-ipadic-utf8 \
            rustc \
            cargo \
            libevent-2.1-7 \
            libgstreamer-plugins-bad1.0-0 \
            libflite1 \
            libgl1-mesa-glx \
            libglib2.0-0 \
            libavif15 \
            gstreamer1.0-libav \
            libavcodec-dev \
            libavdevice-dev \
            libavfilter-dev \
            libavformat-dev \
            libavutil-dev \
            libswresample-dev \
            libswscale-dev \
            pkg-config \
            git 2>&1 | tee -a "$LOG_FILE"
    else
        log_msg "System dependencies appear to be installed."
    fi
fi

# Change to the application directory
cd "$APP_DIR"

# Source environment variables if present
if [ -f "$APP_DIR/pipecat.env" ]; then
    log_msg "Sourcing pipecat.env"
    source "$APP_DIR/pipecat.env"
fi

# Fix for Ultralytics permission issue
export YOLO_CONFIG_DIR="/tmp/Ultralytics"

try_create_venv() {
    local venv_path=$1
    log_msg "Attempting to create venv at $venv_path..."

    if [ -d "$venv_path" ]; then
        log_msg "Removing existing venv at $venv_path..."
        if ! rm -rf "$venv_path"; then
             log_msg "Warning: Failed to remove $venv_path. Permission denied?"
        fi
    fi

    set +e
    python3 -m venv "$venv_path" 2>&1 | tee -a "$LOG_FILE"
    local ret=$?
    set -e

    if [ $ret -ne 0 ]; then
        log_msg "Failed to create venv at $venv_path"
        return 1
    fi
    return 0
}

# Try standard location first, then fallback
VENV_DIR="$APP_DIR/venv"
CONTAINER_VENV_DIR="/opt/pipecat_venv"

ACTIVATE=""
USING_CONTAINER_VENV=0

check_venv_valid() {
    local venv_path=$1
    if [ -d "$venv_path" ] && [ -f "$venv_path/bin/python3" ] && [ -f "$venv_path/bin/activate" ]; then
        # Check mismatch
        local current_ver=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
        local venv_ver=$("$venv_path/bin/python3" -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "invalid")

        if [ "$current_ver" != "$venv_ver" ]; then
            log_msg "Virtual environment at $venv_path version mismatch (System: $current_ver, Venv: $venv_ver)."
            return 1
        fi
        return 0
    fi
    return 1
}

# 1. Try local/development venv (bind mount location)
if check_venv_valid "$VENV_DIR"; then
    log_msg "Found existing valid venv at $VENV_DIR"
    ACTIVATE="$VENV_DIR/bin/activate"
    source "$ACTIVATE"

# 2. If inside Docker, try the baked-in container venv
elif [ "$IS_DOCKER" -eq 1 ] && check_venv_valid "$CONTAINER_VENV_DIR"; then
    log_msg "Found valid container venv at $CONTAINER_VENV_DIR. Using it."
    ACTIVATE="$CONTAINER_VENV_DIR/bin/activate"
    source "$ACTIVATE"
    USING_CONTAINER_VENV=1

# 3. Last resort: Create a new venv in the local directory
else
    log_msg "Virtual environment not found or invalid. Attempting to create at $VENV_DIR..."

    if try_create_venv "$VENV_DIR"; then
        ACTIVATE="$VENV_DIR/bin/activate"
    else
        log_msg "Critical: Failed to create virtual environment."
        exit 1
    fi

    source "$ACTIVATE"
fi

if [ "$USING_CONTAINER_VENV" -eq 1 ]; then
    log_msg "Using container venv. Skipping pip install/playwright install to avoid network issues."
else
    log_msg "Installing dependencies..."
    pip install --upgrade pip 2>&1 | tee -a "$LOG_FILE"
    pip install -r requirements.txt 2>&1 | tee -a "$LOG_FILE"

    log_msg "Installing Playwright browsers..."
    playwright install 2>&1 | tee -a "$LOG_FILE"
fi

log_msg "--- Launching pipecat-app: $(date) ---"

# Add parent directory of app to PYTHONPATH so that 'import pipecatapp' works from within submodules
export PYTHONPATH=$PYTHONPATH:$(dirname "$APP_DIR")

{% if pipecat_deployment_style == 'raw_exec' %}
# For raw_exec, we explicitly manage our own log file via redirection.
PYTHON_EXEC="$(dirname "$ACTIVATE")/python3"
exec "$PYTHON_EXEC" -u "$APP_DIR/app.py" >> "$LOG_FILE" 2>&1
{% else %}
# For Docker, we want logs to stdout/stderr (for `docker logs`) AND to the file (for debugging).
# We use process substitution to pipe to tee.
# Note: We rely on the active venv here.
exec python3 -u "$APP_DIR/app.py" 2>&1 | tee -a "$LOG_FILE"
{% endif %}
