#!/bin/bash
#
# Unified Wrapper Script for pipecatapp
#
# This script is generated by Ansible and ensures that the pipecat application
# is run correctly in both raw_exec and Docker environments.

# Exit immediately if a command exits with a non-zero status.
set -e

# Redirect all output to stderr to ensure it appears in Nomad/Docker logs
exec 1>&2

# Install system dependencies if running as root in a Debian-based system (e.g. Docker dev mode)
if [ -f "/etc/debian_version" ] && [ "$(id -u)" -eq 0 ]; then
    if ! command -v git &> /dev/null || ! command -v pkg-config &> /dev/null; then
        echo "Installing system dependencies..."
        apt-get update && apt-get install -y --no-install-recommends \
            build-essential \
            python3-dev \
            portaudio19-dev \
            mecab \
            libmecab-dev \
            mecab-ipadic-utf8 \
            rustc \
            cargo \
            libevent-2.1-7 \
            libgstreamer-plugins-bad1.0-0 \
            libflite1 \
            libgl1-mesa-glx \
            libglib2.0-0 \
            libavif15 \
            gstreamer1.0-libav \
            libavcodec-dev \
            libavdevice-dev \
            libavfilter-dev \
            libavformat-dev \
            libavutil-dev \
            libswresample-dev \
            libswscale-dev \
            pkg-config \
            git
    else
        echo "System dependencies appear to be installed."
    fi
fi

# Change to the application directory
cd "{{ pipecat_app_dir }}"

# Source environment variables if present
if [ -f "{{ pipecat_app_dir }}/pipecat.env" ]; then
    source "{{ pipecat_app_dir }}/pipecat.env"
fi

try_create_venv() {
    local venv_path=$1
    echo "Attempting to create venv at $venv_path..."

    if [ -d "$venv_path" ]; then
        echo "Removing existing venv at $venv_path..."
        if ! rm -rf "$venv_path"; then
             echo "Warning: Failed to remove $venv_path. Permission denied?"
        fi
    fi

    set +e
    python3 -m venv "$venv_path"
    local ret=$?
    set -e

    if [ $ret -ne 0 ]; then
        echo "Failed to create venv at $venv_path"
        return 1
    fi
    return 0
}

# Try standard location first, then fallback
VENV_DIR="{{ pipecat_app_dir }}/venv"
FALLBACK_VENV_DIR="/opt/venv"
EMERGENCY_VENV_DIR="/tmp/venv"

ACTIVATE=""

if [ -f "$VENV_DIR/bin/activate" ]; then
    echo "Found existing venv at $VENV_DIR"
    ACTIVATE="$VENV_DIR/bin/activate"
    source "$ACTIVATE"
else
    echo "Virtual environment not found. Attempting to create..."

    if try_create_venv "$VENV_DIR"; then
        ACTIVATE="$VENV_DIR/bin/activate"
    elif try_create_venv "$FALLBACK_VENV_DIR"; then
        ACTIVATE="$FALLBACK_VENV_DIR/bin/activate"
    elif try_create_venv "$EMERGENCY_VENV_DIR"; then
        ACTIVATE="$EMERGENCY_VENV_DIR/bin/activate"
    else
        echo "Critical: Failed to create virtual environment in all locations."
        exit 1
    fi

    source "$ACTIVATE"
fi

echo "Installing dependencies..."
pip install --upgrade pip
pip install -r requirements.txt

echo "Installing Playwright browsers..."
playwright install

echo "--- Starting pipecat-app: $(date) ---"

# Add parent directory of app to PYTHONPATH so that 'import pipecatapp' works from within submodules
export PYTHONPATH=$PYTHONPATH:$(dirname "{{ pipecat_app_dir }}")

{% if pipecat_deployment_style == 'raw_exec' %}
# For raw_exec, we manage our own log file.
LOG_FILE="{{ pipecat_log_file }}"
touch "$LOG_FILE"
exec "{{ pipecat_app_dir }}/venv/bin/python3" "{{ pipecat_app_dir }}/app.py" >> "$LOG_FILE" 2>&1
{% else %}
# For Docker, we log to stdout/stderr and let the container runtime handle it.
# Note: We rely on the active venv here.
exec python3 "{{ pipecat_app_dir }}/app.py"
{% endif %}
