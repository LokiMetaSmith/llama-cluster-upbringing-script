diff --git a/tools/server/server-common.cpp b/tools/server/server-common.cpp
index a853f65c8..360d14745 100644
--- a/tools/server/server-common.cpp
+++ b/tools/server/server-common.cpp
@@ -153,6 +153,20 @@ std::vector<size_t> lora_get_enabled_ids(const std::vector<common_adapter_lora_i
     return enabled_ids;
 }

+std::vector<common_control_vector_load_info> parse_control_vector_request(const json & data) {
+    std::vector<common_control_vector_load_info> vectors;
+
+    for (const auto & entry : data) {
+        std::string fname = json_value(entry, "fname", std::string());
+        float strength = json_value(entry, "strength", 0.0f);
+        if (!fname.empty()) {
+            vectors.push_back({strength, fname});
+        }
+    }
+
+    return vectors;
+}
+
 //
 // base64 utils (TODO: use the base64::decode from base64.hpp)
 //
diff --git a/tools/server/server-common.h b/tools/server/server-common.h
index 2629a6bee..37431fab9 100644
--- a/tools/server/server-common.h
+++ b/tools/server/server-common.h
@@ -114,6 +114,12 @@ bool are_lora_equal(
 // get the ids of all enabled loras
 std::vector<size_t> lora_get_enabled_ids(const std::vector<common_adapter_lora_info> & loras);

+//
+// control vector utils
+//
+
+std::vector<common_control_vector_load_info> parse_control_vector_request(const json & data);
+
 //
 // server_tokens
 //
diff --git a/tools/server/server-context.cpp b/tools/server/server-context.cpp
index ceafcac17..a17fc7988 100644
--- a/tools/server/server-context.cpp
+++ b/tools/server/server-context.cpp
@@ -1923,6 +1923,43 @@ private:
                     res->id = task.id;
                     queue_results.send(std::move(res));
                 } break;
+            case SERVER_TASK_TYPE_SET_CONTROL_VECTORS:
+                {
+                    auto & cv_infos = task.set_control_vectors;
+                    SRV_INF("setting control vectors, count=%zu\n", cv_infos.size());
+                    for (const auto & info : cv_infos) {
+                        SRV_INF("  - %s (str=%.2f)\n", info.fname.c_str(), info.strength);
+                    }
+
+                    params_base.control_vectors = cv_infos;
+
+                    common_control_vector_data cv_data = common_control_vector_load(cv_infos);
+
+                    if (cv_data.n_embd == -1) {
+                         SRV_ERR("%s", "failed to load control vectors\n");
+                         // If load fails, we clear the current vectors to be safe/consistent?
+                         // Or maybe we should keep the old ones?
+                         // For now, let's clear to avoid stale state if the user intended to switch.
+                         llama_apply_adapter_cvec(ctx, nullptr, 0, 0, 0, 0);
+                    } else if (cv_data.data.empty()) {
+                        SRV_INF("%s", "clearing control vectors\n");
+                        llama_apply_adapter_cvec(ctx, nullptr, 0, 0, 0, 0);
+                    } else {
+                        int il_start = params_base.control_vector_layer_start;
+                        int il_end   = params_base.control_vector_layer_end;
+
+                        int ret = llama_apply_adapter_cvec(ctx, cv_data.data.data(), cv_data.data.size(), cv_data.n_embd, il_start, il_end);
+                        if (ret != 0) {
+                            SRV_ERR("failed to apply control vectors, ret=%d\n", ret);
+                        } else {
+                            SRV_INF("%s", "control vectors applied successfully\n");
+                        }
+                    }
+
+                    auto res = std::make_unique<server_task_result_apply_control_vectors>();
+                    res->id = task.id;
+                    queue_results.send(std::move(res));
+                } break;
         }
     }

@@ -2879,6 +2916,13 @@ server_response_reader server_context::get_response_reader() {
     return impl->get_response_reader();
 }

+void server_context::update_control_vectors(const std::vector<common_control_vector_load_info> & vectors) {
+    server_task task(SERVER_TASK_TYPE_SET_CONTROL_VECTORS);
+    task.id = impl->queue_tasks.get_new_id();
+    task.set_control_vectors = vectors;
+    impl->queue_tasks.post(std::move(task));
+}
+
 server_context_meta server_context::get_meta() const {
     auto bos_id = llama_vocab_bos(impl->vocab);
     auto eos_id = llama_vocab_eos(impl->vocab);
@@ -3904,6 +3948,44 @@ void server_routes::init_routes() {
         res->ok(result->to_json());
         return res;
     };
+
+    this->get_control_vectors = [this](const server_http_req & req) {
+        auto res = create_response();
+        // TODO: implement getting current control vectors state
+        res->ok(json::array());
+        return res;
+    };
+
+    this->post_control_vectors = [this](const server_http_req & req) {
+        auto res = create_response();
+        const json body = json::parse(req.body);
+        if (!body.is_array()) {
+            res->error(format_error_response("Request body must be an array", ERROR_TYPE_INVALID_REQUEST));
+            return res;
+        }
+
+        auto & rd = res->rd;
+        {
+            server_task task(SERVER_TASK_TYPE_SET_CONTROL_VECTORS);
+            task.id = rd.get_new_id();
+            task.set_control_vectors = parse_control_vector_request(body);
+            rd.post_task(std::move(task));
+        }
+
+        auto result = rd.next(req.should_stop);
+        if (!result) {
+            GGML_ASSERT(req.should_stop());
+            return res;
+        }
+
+        if (result->is_error()) {
+            res->error(result->to_json());
+            return res;
+        }
+
+        res->ok(result->to_json());
+        return res;
+    };
 }

 std::unique_ptr<server_res_generator> server_routes::handle_slots_save(const server_http_req & req, int id_slot) {
diff --git a/tools/server/server-context.h b/tools/server/server-context.h
index c0b5d373f..633e8230a 100644
--- a/tools/server/server-context.h
+++ b/tools/server/server-context.h
@@ -66,6 +66,9 @@ struct server_context {
     // get server metadata (read-only), can only be called after load_model()
     // not thread-safe, should only be used from the main thread
     server_context_meta get_meta() const;
+
+    // update control vectors
+    void update_control_vectors(const std::vector<common_control_vector_load_info> & vectors);
 };


@@ -107,6 +110,8 @@ struct server_routes {
     server_http_context::handler_t post_rerank;
     server_http_context::handler_t get_lora_adapters;
     server_http_context::handler_t post_lora_adapters;
+    server_http_context::handler_t get_control_vectors;
+    server_http_context::handler_t post_control_vectors;
 private:
     std::unique_ptr<server_res_generator> handle_completions_impl(
             const server_http_req & req,
diff --git a/tools/server/server-task.h b/tools/server/server-task.h
index a69e8f1a3..3ab011d69 100644
--- a/tools/server/server-task.h
+++ b/tools/server/server-task.h
@@ -26,6 +26,7 @@ enum server_task_type {
     SERVER_TASK_TYPE_SLOT_ERASE,
     SERVER_TASK_TYPE_GET_LORA,
     SERVER_TASK_TYPE_SET_LORA,
+    SERVER_TASK_TYPE_SET_CONTROL_VECTORS,
 };

 // TODO: change this to more generic "response_format" to replace the "format_response_*" in server-common
@@ -165,6 +166,9 @@ struct server_task {
     // used by SERVER_TASK_TYPE_SET_LORA
     std::map<int, float> set_lora; // mapping adapter ID -> scale

+    // used by SERVER_TASK_TYPE_SET_CONTROL_VECTORS
+    std::vector<common_control_vector_load_info> set_control_vectors;
+
     server_task() = default;

     server_task(server_task_type type) : type(type) {}
@@ -553,6 +557,14 @@ struct server_task_result_apply_lora : server_task_result {
     virtual json to_json() override;
 };

+struct server_task_result_apply_control_vectors : server_task_result {
+    virtual json to_json() override {
+        return {
+            {"success", true}
+        };
+    }
+};
+
 struct server_prompt_checkpoint {
     llama_pos pos_min;
     llama_pos pos_max;
diff --git a/tools/server/server.cpp b/tools/server/server.cpp
index d3d431602..60fd2e13d 100644
--- a/tools/server/server.cpp
+++ b/tools/server/server.cpp
@@ -194,6 +194,9 @@ int main(int argc, char ** argv) {
     // LoRA adapters hotswap
     ctx_http.get ("/lora-adapters",       ex_wrapper(routes.get_lora_adapters));
     ctx_http.post("/lora-adapters",       ex_wrapper(routes.post_lora_adapters));
+    // Control vectors hotswap
+    ctx_http.get ("/control-vectors",     ex_wrapper(routes.get_control_vectors));
+    ctx_http.post("/control-vectors",     ex_wrapper(routes.post_control_vectors));
     // Save & load slots
     ctx_http.get ("/slots",               ex_wrapper(routes.get_slots));
     ctx_http.post("/slots/:id_slot",      ex_wrapper(routes.post_slots));
